"""
Backtesting Module

This module contains functions to backtest trading signals generated by ML models.
"""

import pandas as pd
import numpy as np
from typing import Tuple, Dict, Any
import matplotlib.pyplot as plt
import os


def generate_signals(
    y_pred_proba: np.ndarray,
    threshold: float = 0.55
) -> np.ndarray:
    """
    Generate binary trading signals from probability predictions.
    
    Args:
        y_pred_proba: Probability predictions (array of probabilities)
        threshold: Probability threshold for signal generation (default: 0.55)
    
    Returns:
        Binary signal array: 1 for long, 0 for flat
    """
    signals = (y_pred_proba > threshold).astype(int)
    return signals


def compute_returns_from_signals(
    signals: np.ndarray,
    returns: pd.Series | np.ndarray,
    transaction_cost: float = 0.0002,
) -> pd.Series | np.ndarray:
    """
    Compute strategy returns from signals and actual returns.
    
    Args:
        signals: Binary trading signals (1 = long, 0 = flat)
        returns: Actual next-day returns (Series or array)
        transaction_cost: Cost per position change, expressed in
            return space (e.g. 2 bps = 0.0002). Default is 0.0
    
    Returns:
        Strategy net returns after transaction costs
        (same type as input returns)
    """
    # Convert to numpy arrays for vectorized computation
    if isinstance(returns, pd.Series):
        returns_array = returns.values
        index = returns.index
        is_series = True
    else:
        returns_array = np.asarray(returns)
        index = None
        is_series = False

    signals_array = np.asarray(signals)

    # Gross strategy returns (signals applied to next-period returns)
    gross_returns = signals_array * returns_array

    # Turnover: |Signal_t - Signal_{t-1}|
    # Assume we start from flat position at t-1 (signal = 0)
    prev_signals = np.roll(signals_array, 1)
    prev_signals[0] = 0
    turnover = np.abs(signals_array - prev_signals)

    # Transaction cost paid on each position change
    transaction_fee = transaction_cost * turnover

    net_returns = gross_returns - transaction_fee

    if is_series:
        return pd.Series(net_returns, index=index)

    return net_returns


def compute_equity_curve(returns: pd.Series | np.ndarray, initial_capital: float = 10000.0) -> pd.Series | np.ndarray:
    """
    Compute equity curve from returns.
    
    Args:
        returns: Strategy returns (Series or array)
        initial_capital: Starting capital (default: $10,000)
    
    Returns:
        Equity curve (same type as input returns)
    """
    # Convert to numpy array for computation if needed
    if isinstance(returns, pd.Series):
        returns_array = returns.values
        is_series = True
        index = returns.index
    else:
        returns_array = returns
        is_series = False
    
    # Cumulative returns
    cumulative_returns = np.cumprod(1 + returns_array)
    
    # Equity curve
    equity = initial_capital * cumulative_returns
    
    # Return as Series if input was Series
    if is_series:
        return pd.Series(equity, index=index)
    else:
        return equity


def compute_performance_metrics(
    returns: pd.Series | np.ndarray,
    equity: pd.Series | np.ndarray
) -> Dict[str, float]:
    """
    Compute backtest performance metrics.
    
    Args:
        returns: Strategy returns (Series or array)
        equity: Equity curve (Series or array)
    
    Returns:
        Dictionary with performance metrics
    """
    # Convert to numpy arrays for computation
    if isinstance(returns, pd.Series):
        returns_array = returns.values
    else:
        returns_array = returns
    
    if isinstance(equity, pd.Series):
        equity_array = equity.values
    else:
        equity_array = equity
    
    # Total return
    total_return = (equity_array[-1] / equity_array[0] - 1) * 100
    
    # Annualized return (assuming 252 trading days per year)
    n_days = len(returns_array)
    years = n_days / 252
    annualized_return = ((equity_array[-1] / equity_array[0]) ** (1 / years) - 1) * 100 if years > 0 else 0
    
    # Volatility (annualized)
    volatility = np.std(returns_array) * np.sqrt(252) * 100
    
    # Sharpe ratio (assuming risk-free rate = 0)
    sharpe_ratio = (annualized_return / volatility) if volatility > 0 else 0
    
    # Maximum drawdown
    running_max = np.maximum.accumulate(equity_array)
    drawdown = (equity_array - running_max) / running_max
    max_drawdown = np.min(drawdown) * 100
    
    # Win rate
    positive_returns = returns_array[returns_array > 0]
    non_zero_returns = returns_array[returns_array != 0]
    win_rate = (len(positive_returns) / len(non_zero_returns)) * 100 if len(non_zero_returns) > 0 else 0
    
    metrics = {
        'total_return_pct': total_return,
        'annualized_return_pct': annualized_return,
        'volatility_pct': volatility,
        'sharpe_ratio': sharpe_ratio,
        'max_drawdown_pct': max_drawdown,
        'win_rate_pct': win_rate
    }
    
    return metrics


def backtest_strategy(
    signals: np.ndarray,
    returns: pd.Series | np.ndarray,
    initial_capital: float = 10000.0,
    transaction_cost: float = 0.0002,
) -> Tuple[pd.Series | np.ndarray, Dict[str, float]]:
    """
    Complete backtest pipeline.
    
    Args:
        signals: Binary trading signals
        returns: Actual next-day returns
        initial_capital: Starting capital
        transaction_cost: Cost per position change, expressed in
            return space (e.g. 2 bps = 0.0002). Default is 0.0
    
    Returns:
        Tuple of (equity curve, performance metrics)
    """
    # Compute strategy returns (net of transaction costs)
    strategy_returns = compute_returns_from_signals(
        signals,
        returns,
        transaction_cost=transaction_cost,
    )
    
    # Compute equity curve
    equity = compute_equity_curve(strategy_returns, initial_capital)
    
    # Compute performance metrics
    metrics = compute_performance_metrics(strategy_returns, equity)
    
    # Add signal count to metrics
    metrics['total_trades'] = int(signals.sum())
    
    return equity, metrics


def plot_equity_curve(
    equity: pd.Series,
    save_path: str = 'outputs/equity_curve.png',
    title: str = 'Equity Curve'
) -> None:
    """
    Plot equity curve.
    
    Args:
        equity: Equity curve series
        save_path: Path to save the figure
        title: Plot title
    """
    # Create output directory if it doesn't exist
    os.makedirs(os.path.dirname(save_path), exist_ok=True)
    
    plt.figure(figsize=(12, 6))
    plt.plot(equity.index, equity.values, linewidth=2, label='Strategy Equity')
    plt.axhline(y=equity.iloc[0], color='r', linestyle='--', alpha=0.5, label='Initial Capital')
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Equity ($)', fontsize=12)
    plt.title(title, fontsize=14, fontweight='bold')
    plt.legend(fontsize=10)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(save_path, dpi=300, bbox_inches='tight')
    plt.close()
    
    print(f"Equity curve saved to {save_path}")


def plot_feature_importance(
    importance_df: pd.DataFrame,
    save_path: str = 'outputs/feature_importance.png',
    title: str = 'Feature Importance'
) -> None:
    """
    Plot feature importance.
    
    Args:
        importance_df: DataFrame with 'feature' and 'importance' columns
        save_path: Path to save the figure
        title: Plot title
    """
    # Create output directory if it doesn't exist
    os.makedirs(os.path.dirname(save_path), exist_ok=True)
    
    plt.figure(figsize=(10, 6))
    plt.barh(importance_df['feature'], importance_df['importance'], color='steelblue')
    plt.xlabel('Importance', fontsize=12)
    plt.ylabel('Feature', fontsize=12)
    plt.title(title, fontsize=14, fontweight='bold')
    plt.gca().invert_yaxis()
    plt.grid(True, alpha=0.3, axis='x')
    plt.tight_layout()
    plt.savefig(save_path, dpi=300, bbox_inches='tight')
    plt.close()
    
    print(f"Feature importance plot saved to {save_path}")

